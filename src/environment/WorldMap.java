/*
 * Rylan Hachey
 * 01/22/2023
 * All of the gui elements of the map the player walks across, generated by a perlin noise algorithm
 */

package environment;
import javadraw.*;
import monster.WildMonster;
import noise.NoiseGenerator;
import enums.*;

public abstract class WorldMap {

    protected int width;
    protected int height;
    protected double[][] values;
    private NoiseGenerator seed;
    protected Screen screen;
    protected int imageSize;
    protected Image[][] highImages;
    protected Image[][] medImages;
    protected Image[][] lowImages;
    protected int screenWidth;
    protected int screenHeight;
    protected Location topLeft = new Location(0, 0);
    protected double range;
    protected double lower;
    private Environment environment;

    public WorldMap(Screen screen, int width, int height, int imageSize, Environment environment) {

        this.width = width;
        this.height = height;
        this.values = new double[width][height];
        this.seed = new NoiseGenerator();
        this.screen = screen;
        this.imageSize = imageSize;
        this.environment = environment;
        this.screenWidth = 800 / imageSize;
        this.screenHeight = 416 / imageSize;
        this.lowImages = new Image[this.screenWidth][this.screenHeight];
        this.medImages = new Image[this.screenWidth][this.screenHeight];
        this.highImages = new Image[this.screenWidth][this.screenHeight];
        this.generateNoise();
        this.generateImages();
        this.render();

    }

    /**
     * Generates the perlin noise for the map, assigning the values to an array of a specified size (size of map)
     */

    private void generateNoise() {

        double upper = 0;

        for (int i = 0; i < this.width; i++) {

            for (int j = 0; j < this.height; j++) {

                this.values[i][j] = this.seed.noise(i, j);
                upper = Math.max(this.values[i][j], upper);
                this.lower = Math.min(this.values[i][j], this.lower);

            }

        }

        this.range = upper - this.lower;

    }

    /**
     * Moves the map in a certain direction, but only if it able to do so (won't let the player go offscreen)
     * @param direction: the direction to be moved
     * @return: if the map actually was able to move
     */

    public boolean mapMove(Direction direction) {

        if (direction == Direction.LEFT && this.topLeft.x() > 0) {

            this.topLeft.x(this.topLeft.x() - 1);
            this.render();
            return true;

        } else if (direction == Direction.RIGHT && this.topLeft.x() < this.width - this.screenWidth) {

            this.topLeft.x(this.topLeft.x() + 1);
            this.render();
            return true;

        } else if (direction == Direction.UP && this.topLeft.y() > 0) {

            this.topLeft.y(this.topLeft.y() - 1);
            this.render();
            return true;

        } else if (direction == Direction.DOWN && this.topLeft.y() < this.height - this.screenHeight) {

            this.topLeft.y(this.topLeft.y() + 1);
            this.render();
            return true;

        }

        return false;

    }

    //setter

    public void visible(boolean visible) {

        for(int i = 0; i < this.screenWidth; i++) {

            for (int j = 0; j < this.screenHeight; j++) {

                this.lowImages[i][j].visible(visible);
                this.medImages[i][j].visible(visible);
                this.highImages[i][j].visible(visible);

            }

        }

    }

    //getter

    public Environment environment() {

        return this.environment;

    }

    //abstract methods to be implemented

    public abstract void render();
    public abstract void generateImages();
    public abstract WildMonster randomMonster(int level);

}
